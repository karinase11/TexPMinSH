\chapter{Proof of concept, praktische Anwendung}\label{chap:experiments}
Die lokale Auswertung persönlicher Daten ist das Hauptargument für eine dezentralisierte Smart Home Steuerung aus Sicht von Konsumenten ist, die, wie in der Befragung des IDC einsehbar ist \cite{IDC}, häufig angeben, dass die mögliche Auswertung ihrer Informationen durch dritte ein ausschlaggebender Faktor gegen die Anschaffung eines solchen Systems ist. 
Der Aufbau dieser Anwendung sieht daher vor, die Datenanalyse vollständig innerhalb des Heimnetzes des Anwenders durchzuführen, sich also auf eine „Small Data“ Analyse zu beschränken und so den Einwänden, die mit „Big Data Mining“ einhergehen, vorzugreifen. 

Um den theoretisch skizzierten Anwendungsfall praktisch zu untersuchen, wird der gewählte Process Mining Algorithmus auf einem einfachen, im lokalen Netz erreichbaren, Server als Dienst implementiert. Dieser wartet auf den Eingang von Eventlogs aus einem Smart Home, verarbeitet die Rohdaten und leitet das resultierende Model an eine Mobile Anwendung weiter. Die Anwendung soll dann dem Anwender die Möglichkeit geben, die vom Process Mining Algorithmus extrahierten Regeln im Smart Home zu integrieren. Wird die Regel vom Nutzer akzeptiert, übernimmt der lokale Server die Implementation der Aufgaben auf den relevanten vernetzten Geräten.

\section{Aufbau und Komponenten der praktischen Anwendung}
Das Smart Home Modell, welches auch zu Testzwecken dieser Arbeit  dient, ist Teil des Inventars des ITOM Instituts und mit unterschiedlichen Sensoren und Aktoren ausgestattet. 
Außerdem wird die Android Anwendung „Grafischer Regeleditor“, die zuvor am ITOM Institut entstandenen ist, als Grundlage für die Kommunikation mit dem Anwender genutzt und um die Funktion der automatisierten Regelerkennung erweitert. 
Die Funktionalität der Kommunikation mit einem lokalen Server und das manuelle Anlegen von Regeln für iot Geräte ist bereits in der gegebenen Anwendung integriert.

Die Auswertung durch das Process Mining, die Archivierung der Eventlogs und die Kommunikation mit den vernetzten Geräten des Smart Homes wird von einem einfachen Server übernommen, konkret wird ein Raspberry Pi 3.0 eingesetzt. Um den Anwender über neue erkannte Muster zu informieren, wird jeweils eine Benachrichtigung an das Mobiltelefon versandt, das Versenden der Benachrichtigung wird vom ‚firebase‘\footnote{https://firebase.google.com/} Dienst übernommen. Diese Aufgabe kann um den Aspekt der Datensicherheit voll zu erfüllen, ebenfalls von einem lokalen Dienst durchgeführt werden.

\section{Dienste und Skripte auf dem Heimserver}
Da die Anwendung auf der Architektur des Projekts ‚Graphischer Regeleditor‘ aufbaut, wird in dieser Arbeit vorausgesetzt, dass openHab als Dienst im Heimnetzwerk des Anwenders verfügbar ist, da auch der 'Graphische Regeleditor' mit einer openHab Instanz kommuniziert, um  da dieser für die Aufgabe der Kommunikation mit den iot Geräten, welche die Einträge für das Process Mining notwendige Ereignislog erstellen, verantwortlich ist. 

Die quelloffene openHAB (open Home Automation Bus) Automatisierungssoftware implementiert eine weite Bandbreite herstellerabhängiger Standards und gewährleistet somit eine Kommunikation zwischen den Technologien bzw. Sensoren. Die openHAB-Software stellt 12 Dienste zur Verfügung, um die von den Sensoren gemessenen Daten zu persistieren. Die Automatisierungslogik der openHAB-Software ist als einfacher Regex-Agent anzusehen. 
Um die Brücke von der unverarbeiteten gesammelten Menge an Ereigniseinträgen zu einer neuen, automatisiert erkannten Regel zu schlagen wird ein Script auf dem Server hinterlegt, welches periodisch alle notwendigen Teilschritte des Prozesses aufruft. Jeweils am ersten Tag jedes Kalendermonats wird die auf dem lokalen Server angelegte Ereignislog geladen und zunächst vom .csv (Comma seperated values) in das .xes Format konvertiert. 

Diese Konvertierung ist ein simpler Vorgang, bei dem jeder Eintrag, der in der csv Datei eine einzelne Instanz einer Aktion eines IoT Geräts repräsentiert, in seine Komponenten gespalten und ins XES Format übertragen wird. Die Komponenten umfassen, wie eingangs beschrieben, den Zeitstempel, den Namen des Geräts - in der Form in der er unter openHab hinterlegt ist - sowie die Aktion oder den Sensorwert der den Eintrag erzeugt hat. Diese Komponenten werden im Ausgangsformat von sog. XML-Tags eingeschlossen, die eine Beschreibung des Inhalts enthalten, so wie es der XES Standard vorsieht. Dieser Schritt erleichtert Mining Algorithmen den Umgang mit der Eingangsdatei. 

%Bei der Untersuchung von unverarbeiteten Eventlogs, die im Smart Living Modellhaus des ITOM Institus entstanden sind, ist erkennbar, dass es bei einigen der im Haus integrierten Geräte dazu kommt, dass sie ein Zeitstempelformat nutzen, welches die Sekunden nicht angibt. Hier ist also vor der Konvertierung ein Vorverarbeitungssschritt notwendig, der über jede Zeile iteriert und die Stempel einander angleicht. Da kein universeller Standard für IoT Logs Branchenweit akzeptiert wird und die Hersteller diese beliebig formatieren können, sind mit jedem weiteren angeschlossenen Gerät auch weitere Abweichungen von der erwarteten Form nicht auszuschließen. Um diesem Problem entgegenzuwirken können Tools wie ‚syslog-ng‘ eingesetzt werden, die in der Lage sind die meisten Formen von Eventlogs auf ein einheitliches Format zu bringen.

Im nächsten Schritt ruft das Script ein in der Programmiersprache Java geschriebenes Programm auf, welches Process Mining auf dem neu entstandenen XES Dokument durchführt. Konkret wird dafür ProM auf dem Server gestartet und das Heuristics Miner Plugin ausgewählt.
Über die Parameter kann die Analyse durch das Heuristic Miner Plugin angepasst werden, eta um Rauschdaten zu unterdrücken oder weitere Attribute zur Berücksichtigung bei der Datenanalyse auszuwählen, falls diese im Eventlog gegeben sind. Der Vorverarbeitungsschritt der Rauschreduzierung ist unerlässlich für die Regelfindung. Es sollten keine Knoten als Teil des Regelvorschlags an den Nutzer gelangen, die nicht definitiv auch Teil seines regulären Ablaufs sind. 

\begin{figure}[!h]
    \centering
    \includegraphics[width=\textwidth,origin=c]{figures/Appbildungen/ServerSchritte.PNG}
    \caption{Verarbeitungsschritte zur Auswertung der Smart Home Daten auf dem Server}
    \label{fig:server}
\end{figure}

In dieser Arbeit wird der Schwellwert für Rauschdaten über einen iterativen Prozess gesucht. Da es im Vorfeld keine Information über die Menge der Rauschdaten im zu untersuchenden Eventlog geben kann, wird wie folgt verfahren. 

Ziel ist es ein Modell der häufigsten und kurzen Routinen zu finden. Genauer soll eine Regel mindestens eine Vorbedingung und eine Aktion enthalten, maximal drei Vorbedingungen werden akzeptiert. Nachdem ein Modell aus zwei Knoten gefunden wurde wird nur dann um einen weiteren Knoten erweitert, wenn dieser genauso häufig Teil des Ablaufs ist wie die bisherigen Elemente. Der Regler für den Häufigkeitsschwellwert (im Plugin 'frequency' genannt) wird mit einem Startwert von 0.9 belegt, ein Petri Netz erzeugt und dessen Knoten gezählt. Der Wert wird inkrementell (Schritte von 0.1) iteriert, bis zwei Knoten ein Modell binlden. Ihre Häufigkeit im Eventlog wird in einer Variable gespeichert. Der Schwellwert iteriert, bis ein weiteres Element in das Modell aufgenommen wird. Hat sich die Häufigkeit dieses Modells im Vergleich zum Vorangegangen reduziert, wird das Modell aus zwei Knoten als korrekte Regel akzeptiert, wenn nicht wird weiter Verfahren bis ein neuer Knoten im Modell erscheint.

Ist dieser Prozess abgeschlossen, ist eine Regel gefunden worden.
Das Modell des Miners wird in das PNML Format übertragen, welches Petri Netze nach dem XML Schema beschreibt.

Abschließend enthält das Script einen Aufruf eines kurzen in Python geschriebenen Programms, welches den Firebase Dienst dazu auffordert eine Benachrichtigung an das Mobile Gerät des Anwenders zu senden, welche den Inhalt des PNML Dokuments enthält. Der Prozess, der auf dem Server stattfindet, ist in wenigen Schritten auf Abbildung  \ref{fig:server} dargestellt.

\section{Mobile Anwendung als Steuerungs- und Kommunikationsschnittstelle}

Um die Regeleditor Anwendung um die Kommunikation mit einem dedizierten Firebase Dienst zu erweitern, wird eine Klasse PMFireBaseMessagingService angelegt. Diese Klasse ist neben der dafür verantwortlich dafür die Regel entgegenzunehmen und übergibt Sie an die an die, im Rahmen dieser Arbeit erzeugte, \textit{PMRule} Klasse, welche verantwortlich für das Übertragen des empfangenen PNML Textes in eine Regelform ist. Konkret wird dies von der Funktion parseReceivedRule() übernommen.
\small
\begin{lstlisting}[language=Java]
       private void parseReceivedRule(JSONArray ruleJSON) throws JSONException {
        PMRule r = new PMRule();
        int lastEntry = 0 ;
        for(int j=0;j<ruleJSON.length();j++){
            Log.d("processmining", "rules Array"+j+": "+ruleJSON.getJSONArray(j));

            if(ruleJSON.getJSONArray(j).length()>1){
                lastEntry = ruleJSON.getJSONArray(j).length()-1;
                Vector<String> preconditions = new Vector<>();
                for(int i=lastEntry; i>=0;i--){
                    if(i==lastEntry)
                        r.setAction(ruleJSON.getJSONArray(j).getString(i));
                    else
                        preconditions.add(ruleJSON.getJSONArray(j).getString(i));
                }
                r.setPrecondition(preconditions);
                PMRules.add(r);
                Log.d("processmining", "IF: "+r.getPrecondition()+" THEN: "+r.getAction());
            }
        }
        Intent pmIntent = new Intent(Main.this, ProcessMiningRuleActivity.class);
        pmIntent.putExtra("IF", r.getPrecondition());
        pmIntent.putExtra("THEN", r.getAction());
        startActivity(pmIntent);
    }
\end{lstlisting}

\begin{wrapfigure}{R}{0.5\textwidth}
  \begin{center}
    \includegraphics[width=0.3\textwidth]{figures/Appbildungen/newRuleDialog.png}
  \end{center}
  \label{fig:appdialog}
  \caption{Proof of Concept: Dialog bei Eingang neuer erkannter Regel}
\end{wrapfigure}
\normalsize

Diese Funktion erlaubt das trennen der Elemente in Vor- und Nachbedingungen, die dann direkt in die vorhandene Datenbank der Anwendung "Grafischer Regeleditor" eingefügt werden können.

Nachdem der Endanwender die Benachrichtigung, die auf dem Mobilen Gerät angezeigt wird, wenn der Firebase Dienst eine neue Regel versendet, wird ein Dialog innerhalb der „Grafischer Regeleditor“ Anwendung gestartet. Ein Beispiel für den Dialog ist auf Abbildung \ref{fig:appdialog} zu sehen. Die Vorbedingungen und Aktionen der Regel werden im Wenn – Dann Format dargestellt. Der Nutzer hat zunächst die Möglichkeit die Regel zu akzeptieren oder abzulehnen. Wird sie abgelehnt, wird die Regel nicht ins lokale openHab System aufgenommen und eine entsprechende Feedback Nachricht an den Server übermittelt. Dieser Schritt soll verhindern dass eine vom Anwender nicht erwünschte Regel wiederholt vorgeschlagen wird. Der Server soll neue Regeln zunächst gegen bestehende und abgelehnte abgleichen, bevor eine neue Anfrage gestellt wird.

Wird der Vorschlag vom Anwender akzeptiert, wird er zu einem weiteren Fenster weitergeleitet, welches ihm die Option bietet, die Regel ohne Anpassungen zu übernehmen, oder aber die vorgeschlagene Regel zu editieren. Beispielsweise können weitere Vorbedingungen oder Aktionen hinzugefügt oder entfernt werden, für diese Funktionalität wird auf das Regelwerk der zur Verfügung gestellten „Grafischer Regeleditor“ App zurückgegriffen. 
Nachdem die Regel vom Nutzer akzeptiert worden ist, wird sie wie in der Vorgängerversion der Anwendung auch in die sqLite Datenbank eingetragen. openHab empfängt die aktualisierte Datenbank und wird nun die Aktion ausführen, sobald die vermerkten Vorbedingungen erfüllt sind.
Weitere Funktionen wie das nachträgliche Entfernen oder Editieren der Regeln stehen dem Anwender wie bereits in der Vorgängerversion zur Verfügung.
Der Clientseitige Prozess wird in Abbildung \ref{fig:Kommunikationsablauf} noch einmal im BPMN Format graphisch dargestellt.
\newpage
\begin{figure}[!ht]
    \centering
    \includegraphics[width= 1.47\textwidth, angle=90,origin=c]{figures/Appbildungen/diagramm_app.PNG}
    \caption{Ablauf der Kommunikation zwischen Endanwender und lokalem Server}
    \label{fig:Kommunikationsablauf}
\end{figure}